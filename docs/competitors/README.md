# Сравнение **Pascal** и **C++** для фронтенда учебного компилятора

---

## 1. Синтаксис циклов, ветвлений и блоков кода

| Особенность           | **Pascal**                                                                                                  | **C++**                                                                               |
| --------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Блоки кода**        | `begin ... end`                                                                                             | `{ ... }`                                                                             |
| **Ветвление**         | `if cond then ... else ...`<br>`case var of ... end;`                                                       | `if (cond) { ... } else { ... }`<br>`switch (var) { case ...; break; }`               |
| **Циклы**             | `for i := 1 to N do ...`<br>`for i := N downto 1 do ...`<br>`while cond do ...`<br>`repeat ... until cond;` | `for (int i = 0; i < N; i++) ...`<br>`while (cond) ...`<br>`do { ... } while (cond);` |
| **Инструкция выхода** | `break`, `continue`; в классическом Pascal — через `goto` или `exit`                                            | `break`, `continue`, `return`                                                         |
| **Вложенность**       | Определяется `begin..end`                                                                                   | Определяется фигурными скобками `{}`                                                  |

**Вывод:**
Pascal проще для парсинга — блоки и циклы имеют чёткие ключевые слова.
C++ требует учёта множества форм циклов и операторов, что делает грамматику сложнее.

---

## 2. Объявление типов переменных и параметров

| Особенность               | **Pascal**                                                                             | **C++**                                                                                          |
| ------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| **Объявление переменной** | `var x: Integer;`                                                                      | `int x;`                                                                                         |
| **Место объявления**      | Только в секции `var` перед `begin`                                                    | В любой точке блока                                                                              |
| **Типизация**   |	Статическая |	Статическая |
| **Передача параметров**   | `procedure f(var x: Integer);` — по ссылке<br>`procedure f(x: Integer);` — по значению | `void f(int &x);` — по ссылке<br>`void f(int x);` — по значению<br>`void f(int *x);` — указатель |
| **Модификаторы**          | `var`, `const`                                                                         | `const`, `&`, `*`                                                                  |
| **Вывод типа**            | Нет (всегда явно)                                                                      | Возможен (`auto`)                                                                    |

**Вывод:**
Pascal строг и декларативен — все переменные должны быть объявлены заранее.
C++ гибче, но требует более сложного синтаксического анализа для квалификаторов и указателей.

---

## 3. Набор типов данных

| Категория        | **Pascal**                     | **C++**                            |
| ---------------- | ------------------------------ | ---------------------------------- |
| **Целые**        | `Integer`, `LongInt`, `Byte`   | `int`, `short`, `long`, `unsigned` |
| **Вещественные** | `Real`, `Single`, `Double`     | `float`, `double`, `long double`   |
| **Логические**   | `Boolean`                      | `bool`                             |
| **Символы**      | `Char`                         | `char`                             |
| **Строки**       | `String` (фиксированной длины) | `std::string`, `char[]`            |
| **Массивы**      | `array[1..N] of T`             | `T arr[N]`, `std::vector<T>`       |
| **Структуры**    | `record`                       | `struct`, `class`                  |
| **Специальные**  | `Set`, `File`                  | `nullptr`                          |
| **Указатели**    | `^INTEGER`	                    | `int*`                             |

**Вывод:**
Типовая система Pascal проще, с минимальным числом неявных преобразований.
C++ богаче по возможностям, но усложняет семантический анализ и проверку типов.

---

## 4. Набор операторов

| Категория              | **Pascal**                       | **C++**                             |                         |        |
| ---------------------- | -------------------------------- | ----------------------------------- | ----------------------- | ------ |
| **Арифметические**     | `+`, `-`, `*`, `/`, `div`, `mod` | `+`, `-`, `*`, `/`, `%`, `++`, `--` |                         |        |
| **Логические**         | `and`, `or`, `not`               | `&&`, `\|`, `!` |
| **Сравнения**          | `=`, `<>`, `<`, `>`, `<=`, `>=`  | `==`, `!=`, `<`, `>`, `<=`, `>=`    |                         |        |
| **Присваивание**       | `:=`                             | `=`                                 |                         |        |
| **Побитовые**          | Нет (в стандарте)             | `&`, `\|`, `^`, `~`, `<<`,`>>`      |
| **Тернарный оператор** | Нет                              | `cond ? a : b`                      |                         |        |
| **Оператор доступа**   | `.`                              | `.`, `->`, `::`                     |                         |        |

**Вывод:**
В C++ больше операторов и приоритетов, что требует сложной грамматики.
В Pascal синтаксис операторов минималистичен и легко разбирается рекурсивным спуском.

---

## 5. Пользовательские функции

| Особенность             | **Pascal**                                           | **C++**                      |
| ----------------------- | ---------------------------------------------------- | ---------------------------- |
| **Объявление**          | `function f(x: Integer): Integer;`<br>`procedure g;` | `int f(int x) { return x; }` |
| **Возврат значения**    | Через имя функции (`f := ...`)            | Через `return`               |
| **Рекурсия**            | Поддерживается                                       | Поддерживается               |
| **Вложенные функции**   | Есть (с доступом к внешним переменным)               | Нет (только через лямбды)    |
| **Перегрузка**          | Нет (в классическом Pascal)                          | Есть                         |
| **Шаблоны**   | Нет                                                  | Да (`template<typename T>`)  |

**Вывод:**
Pascal проще для реализации таблицы символов — нет перегрузки и шаблонов.
C++ требует механизм разрешения перегрузок и параметрических типов.

---

## 6. Пользовательские структуры

| Особенность                  | **Pascal**                                 | **C++**                           |
| ---------------------------- | ------------------------------------------ | --------------------------------- |
| **Определение**              | `type TPoint = record x, y: Integer; end;` | `struct Point { int x; int y; };` |
| **Инкапсуляция**             | Нет модификаторов доступа                  | `public`, `private`, `protected`  |
| **Методы**                   | Нет (в чистом Pascal)                      | Есть (внутри `struct`/`class`)    |
| **Конструкторы/Деструкторы** | Нет                                        | Есть                              |
| **Наследование**             | Нет                                        | Есть                              |

**Вывод:**
Pascal-структуры — простые агрегаты.
C++-структуры — полноценные объекты с методами и инкапсуляцией, что усложняет парсер и семантику.

---

## 7. Работа со строками

| Особенность      | **Pascal**                                     | **C++**                                     |
| ---------------- | ---------------------------------------------- | ------------------------------------------- |
| **Тип**          | `String` (фиксированной длины или управляемый) | `std::string` или `char[]`                  |
| **Индексация**   | 1-based                                        | 0-based                                     |
| **Операции**     | Конкатенация (`+`), `Length`, `Copy`           | Конкатенация (`+`), методы `substr`, `size` |
| **Сравнение**    | `=`, `<>`                                      | `==`, `!=`, `<`, `>`                        |
| **Изменяемость** | Изменяемая                                     | Изменяемая|
| **Ввод/вывод**   | `READLN`, `WRITELN`                            | `std::getline`, `std::cout`                 |

**Вывод:**
Pascal использует встроенные строковые функции.
C++ опирается на стандартную библиотеку и требует дополнительного уровня анализа вызовов.

---

## 8. Работа с массивами

| Особенность         | **Pascal**                        | **C++**                           |
| ------------------- | --------------------------------- | --------------------------------- |
| **Объявление**      | `array[1..N] of Integer;`         | `int arr[N];`, `std::vector<int>` |
| **База индексации** | Может начинаться с любого числа   | Всегда с 0                        |
| **Размер**          | Фиксированный (в классике)        | Статический или динамический      |
| **Доступ**          | `arr[i]`                          | `arr[i]`, `arr.at(i)`             |
| **Проверка границ** | Может быть реализована в рантайме | Не выполняется по умолчанию       |

**Вывод:**
Pascal требует хранить границы массива для семантической проверки.
C++ оставляет ответственность программисту, но предоставляет `std::vector` с безопасным доступом.

---

## 9. Управление памятью

| Особенность                   | **Pascal**                                   | **C++**                                   |
| ----------------------------- | -------------------------------------------- | ----------------------------------------- |
| **Динамическое выделение**    | `new(p)` / `dispose(p)`                      | `new`, `delete`                           |
| **Автоматическое управление** | Частично (в современных диалектах)           | Через RAII, умные указатели               |
| **Область видимости**         | Статическая, стековая                        | Автоматическая, статическая, динамическая |
| **Указатели**                 | Есть, но редко применяются в учебных задачах | Ключевая часть языка                      |
| **Инициализация**             | Не всегда обязательна                        | Обязательно для безопасного кода          |

**Вывод:**
Pascal проще: ручное управление сведено к минимуму.
C++ требует точной семантики владения и освобождения памяти, что влияет на дизайн IR.

---

## 10. Обработка ошибок

| Особенность                 | **Pascal**                                                 | **C++**                              |
| --------------------------- | ---------------------------------------------------------- | ------------------------------------ |
| **Механизм ошибок**         | Проверка условий вручную (`if ... then writeln('Ошибка')`) | Исключения (`try`, `catch`, `throw`) |
| **Типы исключений**         | Нет (в стандарте)                                          | Иерархия `std::exception`            |
| **Альтернатива**            | `exit`, `halt`                                             | Возврат кодов ошибок                 |
| **Диагностика компилятора** | Простая: "Ошибка: ..."                                     | Расширенная с типом и контекстом     |

**Вывод:**
Pascal реализует ошибки процедурно.
C++ требует полноценного механизма исключений и unwinding — сложнее для реализации в учебном фронтенде.